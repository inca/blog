{
    title: 'How to start your own Markdown in 2020',
    date: '2020-01-19',
    tags: ['rho', 'text processing', 'semantic markup', 'software development', 'open source']
}

{.subtitle}
The reasoning behind reinventing the most popular text-to-html markup language in the World.

Ok, here's a brief backstory. Roughly 5 years ago I've quit my job as a jack-of-all-trades-developer at [one company](https://eduterra.pro) and decided to try some new adventures as a plain simple senior developer at [some other company](https://ub.io).

If you work full-time with the same people over a long period and are committed enough to what you do, switching the job can become a life-changing event: you get to meet new kinds of people, you face new kinds of challenges (both technical and not), you adapt (a lot!) to new situations and circumstances, you learn some new awesome things, but equally you have to abandon what you have learned before; ultimately, you learn to give up on things like your past achievements, look critically at your experience and sometimes even have to compromise your "core values" in an effort to be able to reach for a brighter future. Before you know it, you become a different person.

But anyway, this post is not about that. As I learned later, one part of the deal was that I had to abandon some cool open source projects I've created in past ‚Äî¬†no, not because it was forbidden on a new position to commit to open source or anything like that; it's not exactly the "I have no time" issue either: I _did_ have time to maintain these projects, but rather these projects weren't on top of the ever-expanding list of my priorities. Simply speaking, over time I've lost the motivation to push them forward, and absence of leadership is fatal to software. It dies.

One such cool project was [Rho](https://github.com/inca/rho) ‚Äî a Markdown alternative with some cool features and a dash of opinions.

~~~ {.sidenote}
Even if you don't know what Markdown is, there's a decent chance you've seen it and even used it. Basically, it's the thing some software like GitHub or Slack use to make the text you type look fancier. For example, it can render a `*text like this*` into a *text like this*.
~~~

~~~ {.centered}
![Old Rho.js Website, circa 2013](/img/rho/Rho Website circa 2013.png)

{.caption}
Old [Rho.js](https://inca.github.com/rho) website, introduced circa 2013, unmodified since circa 2015. Screenshot taken in 2020. Some stuff no longer works in modern browsers.
~~~

So as part of my New Year Resolutions‚Ñ¢ in 2020 I've promised to myself to:

    1. revive my blogging activities,
    2. revive (and learn to appreciate) some really great things I've created in past.

In case you're reading this, my promises are actually getting fulfilled. Yay! üéâ

## Initial design goals

It may not sound like it, but back in 2013 it was about the same kind of crazy to start implementing a Markdown equivalent as it is in 2020. Turns out, 7 years don't make as much difference as you'd think: there are still plenty of readily available implementations which satisfy _almost_ all possible needs in the text-to-html business. But more importantly: just like 7 years ago, they also leave plenty to be desired.

Back then we decided to go for it for a number of reasons. Here are the ones I managed to derive from a hindsight (not necessarily sorted by importance).

#. We needed a stricter, more predictable rules for core features, which are more easily understood by non-technical people.

    The project was initially conceived for a relatively big e-learning platform featuring its own content management system. Part of making such platform successful was to make sure that non-technical people like professors, tutors, teachers, coaches of many different domains could easily create visually and structurally appealing content which would also be accessible for all sorts of devices and search engines, renderable into PDF and ePub, and friendly to revision control systems (you know, for situations when one person writes a lecture and the other one proof reads it ‚Äî so you'd typically want to avoid data loss if the author later decides to rephrase that ugly sentence).

    In practice, we found authors to be confused by some of the rules, especially the ones which involved nested lists with sub-blocks and magical 4 space indentation which turned everything into "ugly looking text" (of course I'm referring to the indented code block rule). People were creating cheatsheets and have developed some weird 4 space calculation techniques in an effort to keep that semantic markup beast tamed. I bet they also hated us for having them to get used to Markdown and, after a while, abandon their hard earned habits.

    In addition to that, people were producing a lot of content, so it was beneficial for us to reasonably limit the number of ways to achieve a specific semantic construct. Standard Markdown featuring multiple ways of spelling headings, lists, em/strong elements and multiple flavours of code blocks (with magical 4 indentation) wasn't doing much good for people who tried to pick up somebody else's work.

#. We needed more!

    You don't typically need too much from semantic texts when you write READMEs, or quickly put together some comments, or even when you write some technical articles and even certain kinds of blog posts.

    However, sometimes you need _just a tiny bit more_ than Markdown has to offer.

    {.sidenote}
    In an ideal world, one could use a Markdown engine which allowed for implementing extensions to achieve what's desired, instead of completely reimplementing the whole thing from scratch. I'll touch on the extensibility bit later on.

    We were quick to realize that our content needed a bit more stylistic diversity than what can be achieved by any kind of combinations of `p`, `ul`, `ol`, `li`, `hX`, `blockquote`, `pre` + handful more tags that Markdown can spit out.

    The newly introduced concept of "selector expressions" made a whole lot of difference: users could now add arbitrary classes to blocks by specifying `{.things.like.these}` on the first line. Now platform could provide a handful of block types like "note", "pro tip", "warning", etc. to make its authors and readers almost infinitely happy.

    We've also faced some interesting challenges when we first tried to make math formulae with [MathJax](https://www.mathjax.org/) due to extensive use of backslashes in it and how Markdown was eager to digest them all.

    And of course lots of smaller features (like being able to programmatically resolve media references like `![Alt text][some-id-from-database]` or, say, to support reusable markup fragments) definitely helped with engineering a better end product.

#. But we also needed less!

    Wait, what?

    [GitHub Flavoured Markdown Spec](https://github.github.com/gfm/#why-is-a-spec-needed-) makes a good case about how canonical Markdown rules leave many questions unanswered and numerous edge cases unresolved.

    Since we've worked with the authors who were not previously exposed to any kinds of technical-looking language (yes, Markdown still looked very technical to them!) we were able to receive and process the feedback about Markdown usability from them.

    We didn't even need to do any feedback processing to realize that only a handful of rules takes the most heat. Namely:

    - indented code blocks
    - blockquotes

    Apparently, people hated to put extra stuff in front of every line, which they most likely just pasted from their clipboard!
    And the indented code blocks "feature" was a massive point of frustration for those who worked extensively with nested lists.

    My reasoning back then was rougly as follows:

    - Markdown's overarching goal is to make the source readable and understandable, whilst producing a predictable outcome...
    - ... which can be summarized as "usability"...
    - ... but I don't see how counting spaces improves any of that...
    - ... neither do I see how prepending each line with `>` to make it "stand out" makes things better.

    Removing those and a couple more led to a drastically improved authorship experience due to reduced ambiguity and complexity.

    {.subtle}
    Of course I've no fancy charts or metrics to back up my words ‚Äî¬†just people being genuinely grateful. So give or take.

#. Existing solutions work. But how?

    If you're like me, you'd want to sniff around the existing implementations and see if they can be "convinced" to do what I want. Chances are you'd expect to see some proper compiler pipelines with lexers, parsers, ASTs and renderers where you can elegantly add more logic.

    Unfortunately, I was in for a surprise. Most implementations happen to contain pretty much the entire lexing/pasing logic [in a single gazillion-line method](https://github.com/markedjs/marked/blob/master/src/Lexer.js#L55-L401) which is virtually impossible to comprehend, let alone modify or extend. The same is true with a [reference implementation](https://daringfireball.net/projects/markdown/), which is just a myriad of regular expressions executed in a particular order.

    ~~~ {.subtle}
    "Why so complicated?" you'd ask. Well, despite [perceived simplicity](https://stackoverflow.com/questions/55127847/parsing-subset-of-markdown-with-regex), Markdown rules are actually quite complicated. Blocks can be arranged in hierarchies and should be processed recursively; same goes for inline markup which can be nested in each other. In order to tackle all this with regular expressions they need to be executed in a particular order, in a well-established scope and most of the time they also need to contain knowledge of other regular expressions (i.e. other nested markup rules which could interfere with a current lexical scope). Now toss all this into a single lexer method, layer them with tons of `if`, `else`, `switch`, `case` and mutable scope variables ‚Äî¬†and you'll get what's known in the industry as spaghetti. üçù
    ~~~

    Working with code like this is not an option for me. Designing a better solution is. Fwiw I could spend a lot more time in debugging some complicated edge cases than it would take me to design a more appropriate solution whereby each rule is implemented in a modular way with minimal impact on other rules.

#. Ok now this one is tricky. It did not occur to me up until I've implemented my own semantic text markup language. As it turns out, when you have a markup language you can tinker with, you start getting some pretty cool ideas out of nowhere. Suddenly you realize you can do a lot more.

    As an example, this is how I've implemented a superset of semantic markup rules for creating quizzes. You, as an author, would write things like:

    ```{.plaintext}
    2 + 2 =

    ( ) 1
    ( ) 2
    ( ) 3
    (x) 4
    ( ) 5
    ```

    The library would render a form with radio buttons, without leaking any information about the correct answer, and on server side would have ways to validate the submitted answer. We've implemented the same for other types of tasks such as multiple choice, drag-to-order and even type text with diff-based answer assessment. _So freaking cool!_

#. Last but not least, it was fun!

    We tend to forget that software can be a bit more than just means to an end. I'm pretty sure everyone is familiar with this delightful feeling of accomplishment when carefully designed non-trivial program starts to produce the results you expect for the first time.

Bottom line is: Markdown needed a hero 7 years ago, and it still needs one now.

## 2020 re-design objectives

Truth to be told, it is this blog which prompted me to start renovating my poor old library covered with a thick layer of dust. Sure I could just sugar-coat it with type definitions and that would probably be sufficient, but... Ugh. It was published in 2013, but conceived even earlier than that, which means: no modern ECMAScript features, lots of `Foo.prototype.bar = ` assignments, loads of ` var`, etc. Horrible, horrible times.

Despite what [big cats say](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/) I maintain that rewriting software from scratch is still valid and under certain circumstances can actually be the one and only measure that can save the project from a certain death.

But what to do exactly?

Since leadership in software world is just a fancy word to describe one's opinions, I've quickly got mine together and came up with roughly the following plan.

1. *TypeScript.* It makes absolutely no sense to start any serious development for Node.js / Browser library in any other language.

    ~~~ {.subtle}
    TypeScript is pretty much everywhere in the web now. Libs that have views to make it into the second quarter of XXI are already in TypeScript. And those poor ones who did not publish the typings to npm are probably dead. Presence or absence of typings has become a new heuristic of library liveliness.
    ~~~

2. *Extensibility.* Core should not contain any actual text processing rules. Rather, it should be a framework whereby all rules are implemented as separate modules and then can be plugged together to achieve the desired result.

    ~~~ {.subtle}
    This doesn't sound too complicated ‚Äî¬†but only until you get into the nitty gritty details. For example, lists are hierarchical blocks which may consist of other kinds of blocks, code blocks support a limited set of inline rules like escaping commong HTML characters (`&`, `<`, `>`) and are sensitive to indentation, some inline markup would contain nested inline markup and so forth.

    Nevertheless, in my opinion, designing a modular parsing system is one of the most important objectives for Rho. This would allow users to implement their own semantic markup rules and effortlessly add it to the processor, without having to modify the core itself. Imagine the possibilities! üå†
    ~~~

3. *Features vs compatibility.* Initially I took a rather strong stance on compatibility with Markdown. For example, we defined that unordered lists would only use `*` markers (as opposed to Markdown which also supports `-` and `+`). However, over time I've learned that some of these limitations were deal breakers for some users.

    So I decided to relax a couple of constraints in an effort to make Rho more enjoyable experience for those already familiar with Markdown. And whilst 100% compatibility isn't something that I consider useful, I figured that a sweet spot is totally achievable.

    {.subtle}
    In theory, with extensibility it is possible to make Rho closer to full Markdown compatibility via plugins. Perhaps something for community to look into, hehe.

4. *Performance.* Not a crucially important as it is unlikely you would compile megabytes of text in real time. Most content management solutions would just cache the produced html and only re-render when the source has changed.

    ~~~ {.sidenote}
    My initial implementation was almost *4 times slower* than [Marked](https://github.com/markedjs/marked), but I managed to squeeze some juice from it. üí™ It was an enjoyable experience, and I will write a separate post about it.
    ~~~

    But it would still be nice to have at least comparable performance to "competitors".
