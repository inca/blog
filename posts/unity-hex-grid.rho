{
    title: 'Unity Hex Grid System',
    date: '2020-05-14',
    tags: ['Unity', 'GameDev', 'Tutorial', 'Hex Grid', 'Basics'],
    description: 'Tutorial on how to create a hex grid system in Unity, simple and powerful.'
}

<script src="/hexgrid.js">
</script>

In this article I'd like to share a very simple hex grid system I've used in my [Hex Laser Puzzle](https://play.google.com/store/apps/details?id=com.alphamagenta.HexLaser) game.

~figure
    <video width="320" height="240" controls autoplay="true" muted="true">
        <source src="/img/posts/hex/hlp-01.mp4"/>
    </video>

Of course, I only call it "system" because it sounds cooler this way. The core concept is incredibly simple — which makes it immensely powerful, since you can combine it with other components to achieve the functionality needed for your particular needs.

I highly recommend the [Amit's Hex Guide](https://www.redblobgames.com/grids/hexagons/) — to quote from one of the comments, this is indeed a gold mine of information on hexagonal grids. I'll also be referring to it a lot.

{.sidenote}
Also check out the [demo project on GitHub](https://github.com/inca/UnityHexGrid) which contains all the code from this article.

## Introduction: Coordinate Systems

First, let's ask ourselves: what should a _grid system_ do?

Forget about hex for a moment. Say, you want a square grid system for your game. What problems do you expect a grid system to solve?

- You can place the objects on your grid; for example, if the grid is on the XZ floor, then you can just set the Y to zero.
- You know how to obtain the coordinates of the objects on your grid, e.g. by plucking some components of `Vector3` into `Vector2`.
- If you want objects to snap to grid cells: at runtime all you need to do is to `Mathf.Round` the coordinates, whilst in the editor you can simply drag with Control/Command key pressed.
- You may want to actually draw the grid lines on your board/floor — these are usually drawn with either a tileable texture applied on something like a primitive plane, or a shader (or any combination of those).

So there's little point in actually implementing a "square grid system", chiefly because you already have `Vector2` that makes most of the above possible.

Why is hex a different story, then?

~figure
    <svg id="baseGrid"
         class="hexgrid"
         viewBox="-300 -120 600 240">
    </svg>

When presented with a hex grid, we (humans) tend to immediately recognize rows and columns. We're so used to orthogonal systems in our lives that it's natural to apply the paradigm we're so familiar with to all the cases.

Let's try and put our orthogonal axes onto a hex grid.

~figure
    <svg id="gridOrthoAxes"
         class="hexgrid"
         viewBox="-300 -120 600 240">
    </svg>

There are two noteworthy problems with this approach.

- The width of a regular hexagon doesn't match its height; depending on which of the two dimensions is chosen as "unit", the other one will be irrational to this unit.

- The Y axis doesn't reach the "middle dot" of every row. We can also say that every other row have horizontal offset.

Trying to derive a decent logic to address hex cells with orthogonal coordinates is just plain painful. It's time to admit that orthogonal system is just not fit for purpose — and to look for some other, more suitable system.

Luckily, there is just one that works perfectly with hexagons. Behold, the *oblique cartesian system* (also known as "axial" or "skewed"):

~figure
    <svg id="gridObliqueAxes"
         class="hexgrid"
         viewBox="-300 -120 600 240">
    </svg>

Yes, it's pretty much like the orthogonal one, except that the axes are at 60˚ to each other.

{.sidenote}
The names of the axes Q and R are chosen to conform to [Amit's hex guide](https://www.redblobgames.com/grids/hexagons/).

Notice how both axes go through the middle dots of each "column" and "row". Essentially, linear combinations of <span style="color: hsl(190, 80%, 50%)">%%\vec q%%</span> and <span style="color: hsl(290, 80%, 60%)">%%\vec r%%</span> unit vectors cover the entire hex space.

~figure
    <svg id="gridCoordinates"
         class="hexgrid"
         viewBox="-300 -120 600 240">
    </svg>

    ~figcaption Try hovering over this grid and see how each hex cell is addressable with Q and R coordinates.

So implementing a "hex grid system" boils down to creating a `Vector2` equivalent for oblique coordinates (I'll refer to them as "hex coordinates") with conversions to and from our standard orthogonal coordinates.

Everything else would be implemented on top of it. For example, snapping objects to hex grid would be just a matter of getting the rounded hex coordinates and coverting them back to the World coordinates.

~figure
    <video width="320" height="240" controls autoplay="true" muted="true">
        <source src="/img/posts/hex/hlp-02.mp4"/>
    </video>

    ~figcaption Objects snapped to hex grid in Unity Editor.

## Implementation

Before jumping to the code, we have some choices to make.

1. *Orientation*: should each axis go through the vertex of a hexagon or through its side?

2. *Scale*: how much space should a single cell occupy?

So. Hexagons have two radiuses:

- [circumradius](https://en.wikipedia.org/wiki/Circumscribed_circle) %%R%% — the distance from center to vertex, which is also equal to the side of hexagon,
- [inradius](https://en.wikipedia.org/wiki/Incircle_and_excircles_of_a_triangle) %%r%% — the distance from center to side, which is %%{\sqrt 3 \over 2} R%%.

~figure
    <video width="320" height="240" controls autoplay="true" muted="true">
        <source src="/img/posts/hex/cell-radius.mp4"/>
    </video>

    ~figcaption Various choices of hex cell size, compared to a unit sphere.

In the GIF above:

- <span style="color:hsl(40,75%,50%)">orange hexagon</span> has circumradius %%R = 1%%
- <span style="color:hsl(200,75%,50%)">blue hexagon</span> has circumradius %%R = 0.5%%
- <span style="color:hsl(150,60%,45%)">green hexagon</span> has inradius %%r = 0.5%%

I went for the last option (the one with <span style="color:hsl(150,60%,45%)">inradius %%r = 0.5%%</span>), because this way a primitive unit sphere fits perfectly into a single hex grid and nothing overlaps.

~figure
    ![](/img/posts/hex/capsule-collider.jpg)

    ~figcaption A capsule collider with radius %%0.5%% around mirror piece.

This also means that both axes go through the side of the hexagons, and not though their vertices.

As for the orientation, I went with aligning Q axis with World X. This one is quite arbitrary, but if it helps: Blender creates cylinders (which you can turn into perfect hexagonal prisms) in this same orientation by default, so you don't have to rotate anything.

## Put Together

With all the above in mind let's create our `Hex` class stores axial coordinates and converts them into world coordinates.

``` {.cs}
// Hex.cs
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public struct Hex {

    public static float RADIUS = 0.5f;
    public static Vector2 Q_BASIS = new Vector2(2f, 0);
    public static Vector2 R_BASIS = new Vector2(1f, Mathf.Sqrt(3));
    public static Vector2 Q_INV = new Vector2(1f / 2, - Mathf.Sqrt(3) / 6);
    public static Vector2 R_INV = new Vector2(0, Mathf.Sqrt(3) / 3);

    public static Hex FromPlanar(Vector2 planar) {
        float q = Vector2.Dot(planar, Q_INV) / RADIUS;
        float r = Vector2.Dot(planar, R_INV) / RADIUS;
        return new Hex(q, r);
    }

    public static Hex FromWorld(Vector3 world) {
        return FromPlanar(new Vector2(world.x, world.z));
    }

    public int q;
    public int r;

    public Hex(float q, float r) :
        this(Mathf.RoundToInt(q), Mathf.RoundToInt(r)) {}

    public Hex(int q, int r) {
        this.q = q;
        this.r = r;
    }

    public Vector2 ToPlanar() {
        return (Q_BASIS * q + R_BASIS * r) * RADIUS;
    }

    public Vector3 ToWorld(float y = 0f) {
        Vector2 planar = ToPlanar();
        return new Vector3(planar.x, y, planar.y);
    }

    public override bool Equals(System.Object obj) {
        Hex hex = (Hex)obj;
        return (q == hex.q) && (r == hex.r);
    }

    public override int GetHashCode() {
        return q * 37 + r * 31;
    }

    public override string ToString() {
        return "(" + q + ";" + r + ")";
    }

}
```

{.sidenote}
With `Equals` and `GetHashCode` implemented you can use your hexes as `Dictionary` keys, or put them into `HashSet`s — very handy for things like breadth-first search. (Also, sorry if it's obvious)

Here we have static methods `Hex.FromPlanar` and `Hex.FromWorld` — these allow obtainining `Hex` from World coordinates (`Vector2` and `Vector3` respectively). Instance methods `hex.ToPlanar` and `hex.ToWorld` do the reverse and convert hex coordinates to World coordinates.

I won't go into any detail with regards to the actual conversion — this stuff is brilliantly explained in the [Amit's hex guide](https://www.redblobgames.com/grids/hexagons/). Just note how the orientation and scaling decisions are encapsulated in a bunch of static variables at the top (`Q_BASIS`, `R_BASIS`, `Q_INV`, `R_INV`) — so if you need to change the orientation, these are the things you'd need to tweak.

## Snapping Objects

With the essentials in place we can now implement a component for snapping objects to hex grid roughly as follows:

1. convert `transform.position` to `hex` using `Hex.FromWorld(transform.position)`;
2. convert `hex` back to `Vector3` using `hex.ToWorld()`.

Hex coordinates are integers, so rounding will provide us with that snap we were looking for.

Let's call our component `HexSnap`.

``` {.cs}
// HexSnap.cs
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[ExecuteInEditMode]
public class HexSnap : MonoBehaviour {

    public Hex hex {
        get {
            return Hex.FromWorld(transform.position);
        }
    }

    public Hex localHex {
        get {
            return Hex.FromWorld(transform.localPosition);
        }
    }

    public void ApplyTransform() {
        Vector3 newPos = this.localHex.ToWorld(0f);
        transform.localPosition = newPos;
    }

    #if UNITY_EDITOR
    void Update() {
        if (!Application.isPlaying) {
            ApplyTransform();
        }
    }

    void OnDrawGizmosSelected() {
        UnityEditor.Handles.Label(transform.position, hex.ToString());
    }
    #endif

}
```

Now attach it to your game object and observe how it snaps onto hex grid floor on XZ plane.

## Neighbours

Each hex cell has 6 neighbouring cells.

~figure
    ![](/img/posts/hex/neighbours.jpg|240)

Let's list the neighbours of "cell zero" starting with the rightmost one, in counter clockwise direction.

``` {.cs}
// Hex.cs
// ...
    public static Hex[] AXIAL_DIRECTIONS = new Hex[] {
        new Hex(1, 0),
        new Hex(0, 1),
        new Hex(-1, 1),
        new Hex(-1, 0),
        new Hex(0, -1),
        new Hex(1, -1),
    };
```

So to find all neighbours of any given `hex` all we need to do is to loop through these axial directions and add corresponding `q` and `r` components.

The only thing missing is component-wise arithmetics of `Hex` instances, so let's add them.

``` {.cs}
// Hex.cs
// ...
    public static Hex zero = new Hex(0, 0);

    public static Hex operator +(Hex a, Hex b) {
        return new Hex(a.q + b.q, a.r + b.r);
    }

    public static Hex operator -(Hex a, Hex b) {
        return new Hex(a.q - b.q, a.r - b.r);
    }
```

Awesome! Now let's add few methods to our `Hex`:

- `Hex GetNeighbour(int dir)` to get the neighbouring cell in specified direction,
- `IEnumerable<Hex> Neighbours()` to get all cell neighbours.

``` {.cs}
// Hex.cs
// ...
    public Hex GetNeighbour(int dir) {
        Hex incr = AXIAL_DIRECTIONS[dir % AXIAL_DIRECTIONS.Length];
        return this + incr;
    }

    public IEnumerable<Hex> Neighbours() {
        foreach (Hex dir in AXIAL_DIRECTIONS) {
            yield return this + dir;
        }
    }
```

Finally, let's visualize the neighbours. Let's create a `HexNeighbours` which would draw gizmos on all neighbouring hex cells:

```
// HexNeighbours.cs
using UnityEngine;

[ExecuteInEditMode]
public class HexNeighbours : MonoBehaviour {

    public Hex hex {
        get {
            return Hex.FromWorld(transform.position);
        }
    }

    void OnDrawGizmosSelected() {
        Gizmos.color = Color.yellow;
        foreach (Hex neighbour in hex.Neighbours()) {
            Gizmos.DrawSphere(neighbour.ToWorld(), .25f);
        }
    }

}
```

~figure

    <video width="320" height="240" controls autoplay="true" muted="true">
        <source src="/img/posts/hex/neighbours-gizmos.mp4"/>
    </video>

    ~figcaption Yellow gizmos showing neighbouring hex cells of currently selected object.

{.sidenote}
It is very convenient to visualize stuff with gizmos — highly recommended.

## Other Algorithms

If you're still with me, then by now you should be getting the feel for it.

Once again I'd like to point you to [the most awesome hex grid guides ever created](https://www.redblobgames.com/grids/hexagons) — from here you can choose an algorithm that is relevant to the game you're making and port it to our hex grid system without much problem.

As an exercise, let's implement the hex rings traversal.

``` {.cs}
// Hex.cs
// ...

    public static IEnumerable<Hex> Ring(Hex center, int radius) {
        Hex current = center + new Hex(0, -radius);
        foreach (Hex dir in AXIAL_DIRECTIONS) {
            for (int i = 0; i < radius; i++) {
                yield return current;
                current = current + dir;
            }
        }
    }

    public static IEnumerable<Hex> Spiral(Hex center, int minRadius, int maxRadius) {
        if (minRadius == 0) {
            yield return center;
            minRadius += 1;
        }
        for (int r = minRadius; r <= maxRadius; r++) {
            var ring = Ring(center, r);
            foreach (Hex hex in ring) {
                yield return hex;
            }
        }
    }
```

As before, let's visualize it by creating a dummy component and drawing some gizmos.

``` {.cs}
// HexRings.cs
using UnityEngine;

[ExecuteInEditMode]
public class HexRings : MonoBehaviour {

    [Range(1, 10)]
    public int minRadius;
    [Range(1, 10)]
    public int maxRadius;

    public Hex hex {
        get {
            return transform.position.ToHex();
        }
    }

    void OnDrawGizmosSelected() {
        Gizmos.color = Color.magenta;
        foreach (Hex hex in Hex.Spiral(this.hex, minRadius, maxRadius)) {
            Gizmos.DrawSphere(hex.ToWorld(), .25f);
        }
    }

}
```

~figure
    <video width="320" height="240" controls autoplay="true" muted="true">
        <source src="/img/posts/hex/rings.mp4"/>
    </video>

    ~figcaption Generated hex rings.

## Conclusion

Thanks for sticking with me till the end. Time to say goodbye 👋

Hope this was useful, and looking forward to seeing you build something hexy with these ideas.

Also, don't forget to check out the [demo project on GitHub](https://github.com/inca/UnityHexGrid).

## Addenda

Here's how to quickly create a 3D hexagon piece in Blender.

~figure
    ![](/img/posts/hex/blender-hex.jpg)

    ~figcaption Blender cylinders use circumradius;<br/>
        type `sqrt(3) / 3` to get the cylinder with inradius %%0.5%%
