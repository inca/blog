<!DOCTYPE html><html lang="en"><head><title>Unity Hex Grid System · Boris Okunskiy</title><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400i,700,700i&amp;display=optional"><link rel="stylesheet" href="/build/index.css"><link rel="shortcut icon" href="/favicon.ico"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#dd3c49"><meta name="apple-mobile-web-app-status-bar-style" content="#dd3c49"></head><body><div class="header"><div class="header__container container"><div class="topnav"><div class="topnav__logo"><a class="logo topnav__link" href="/" title="Boris Okunskiy"><svg class="icon-bo" viewBox="0 0 64 64"><defs><linearGradient id="gradRed" gradientTransform="rotate(30)"><stop offset="0%" stop-color="hsl(355deg, 70%, 85%)"></stop><stop offset="100%" stop-color="hsl(355deg, 70%, 55%)"></stop></linearGradient><linearGradient id="gradMagenta" gradientTransform="rotate(30)"><stop offset="0%" stop-color="hsl(320deg, 50%, 85%)"></stop><stop offset="100%" stop-color="hsl(320deg, 50%, 60%)"></stop></linearGradient></defs><g transform="scale(1, .9)" transform-origin="center"><g transform="matrix(1.83333,0,0,2.33333,-13,-21.6667)"><circle fill="url(#gradMagenta)" cx="30" cy="23" r="12"></circle></g><g transform="matrix(0.875,0,0,0.875,10,4)"><path fill="url(#gradRed)" d="M-11.429,0L11.429,0C20.259,0 27.429,7.169 27.429,16C27.429,24.831 20.259,32 11.429,32C20.259,32 27.429,39.169 27.429,48C27.429,56.831 20.259,64 11.429,64L-11.429,64L-11.429,0Z"></path></g></g></svg><span class="logo__name" data-name="Boris"></span><span class="logo__dot logo__particle"></span><span class="logo__name" data-name="Okunskiy"></span></a></div><div class="topnav__icons"><a class="topnav__icon" href="https://twitter.com/boris_okunskiy" title="Boris on Twitter"><svg class="icon-twitter" viewBox="0 0 128 128"><g transform="matrix(1.12952,0,0,1.12952,-5.77298,-6.08744)"><path d="M106.3,36.6C103.5,37.9 100.3,38.7 97.3,39.2C98.8,39 100.9,36.3 101.8,35.3C103.1,33.7 104.2,31.8 104.8,29.8C104.9,29.6 104.9,29.4 104.8,29.3C104.6,29.2 104.5,29.3 104.3,29.3C100.9,31.1 97.4,32.5 93.6,33.4C93.3,33.5 93.1,33.4 92.9,33.2C92.6,32.8 92.3,32.5 92,32.2C90.4,30.9 88.7,29.8 86.8,29C84.3,28 81.5,27.5 78.8,27.7C76.2,27.9 73.6,28.6 71.3,29.8C69,31 66.9,32.7 65.2,34.8C63.5,36.9 62.2,39.4 61.6,42.1C61,44.7 61,47.2 61.4,49.8C61.5,50.2 61.4,50.3 61,50.2C46.2,48.1 34,42.9 24.1,31.6C23.7,31.1 23.4,31.1 23.1,31.6C18.8,38.1 20.9,48.5 26.3,53.7C27,54.4 27.8,55.1 28.6,55.7C28.3,55.8 24.7,55.4 21.5,53.7C21.1,53.4 20.9,53.6 20.8,54.1C20.8,54.8 20.8,55.4 20.9,56.2C21.7,62.8 26.3,68.9 32.5,71.2C33.2,71.5 34.1,71.8 34.9,71.9C33.5,72.2 32,72.4 27.9,72.1C27.4,72 27.2,72.3 27.4,72.7C30.4,81.1 37,83.6 42,85C42.7,85.1 43.3,85.1 44,85.3C44,85.4 43.9,85.4 43.9,85.4C42.3,87.9 36.6,89.8 33.9,90.7C29.1,92.4 23.8,93.1 18.7,92.6C17.9,92.5 17.7,92.5 17.5,92.6C17.3,92.7 17.5,92.9 17.7,93.1C18.7,93.8 19.8,94.4 20.9,95C24.1,96.7 27.5,98.1 31,99.1C49.2,104.1 69.8,100.4 83.5,86.8C94.2,76.2 98,61.5 98,46.7C98,46.1 98.7,45.8 99.1,45.5C101.9,43.4 104.1,40.9 106.2,38.1C106.7,37.5 106.6,36.9 106.6,36.7L106.6,36.6C106.6,36.4 106.7,36.4 106.3,36.6Z"></path></g></svg></a><a class="topnav__icon" href="https://github.com/inca" title="Boris on GitHub"><svg class="icon-gh" viewBox="0 0 128 128"><g transform="matrix(3.78734,0,0,3.78734,63.9943,124.66)"><path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904"></path></g></svg></a></div></div></div></div><div class="content"><div class="content__container container"><article class="post" data-post-id="unity-hex-grid"><header class="post__header"><div class="post__cal cal" title="May 14, 2020 12:00 AM"><div class="cal__day">14</div><div class="cal__sub"><div class="cal__month">May</div><div class="cal__year">20</div></div></div><h1 class="post__title">Unity Hex Grid System</h1><div class="post__tagline"><a class="post-tag" href="/posts?tag=Unity">Unity</a><a class="post-tag" href="/posts?tag=GameDev">GameDev</a><a class="post-tag" href="/posts?tag=Tutorial">Tutorial</a><a class="post-tag" href="/posts?tag=Hex Grid">Hex Grid</a><a class="post-tag" href="/posts?tag=Basics">Basics</a></div></header><div class="post__content"><script src="/build/hexgrid.js">
</script>
<p>In this article I’d like to share a very simple hex grid system I’ve used in my <a href="https://play.google.com/store/apps/details?id=com.alphamagenta.HexLaser">Hex Laser Puzzle</a> game.</p>
<figure><video width="320" height="240" controls autoplay="true" muted="true">
        <source src="/img/posts/hex/hlp-01.mp4"/>
    </video>
<p></p></figure>
<p>Of course, I only call it “system” because it sounds cooler this way. The core concept is incredibly simple — which makes it immensely powerful, since you can combine it with other components to achieve the functionality needed for your particular needs.</p>
<p>I highly recommend the <a href="https://www.redblobgames.com/grids/hexagons/">Amit’s Hex Guide</a> — to quote from one of the comments, this is indeed a “gold mine” of information on hexagonal grids. I’ll also be referring to it a lot.</p>
<p class="sidenote">Also check out the <a href="https://github.com/inca/UnityHexGrid">demo project on GitHub</a> which contains all the code from this article.</p>
<h2>Introduction: Coordinate Systems</h2>
<p>First, let’s ask ourselves: what should a “grid system” do?</p>
<p>Forget about hex for a moment. Say, you want a square grid system for your game (you know, the good ol’ orthogonal Cartesian system that all our games use already). Would you go around wondering how to create a “square grid system”?</p>
<p>Probably not, because you sort of have everything you need already, specifically:</p>
<ul><li>you can place the objects on your “grid”; for example, if your grid is on the XZ “floor”, then you can just set the Y to zero;</li>
<li>you know how to obtain the coordinates of the objects on your grid, e.g. by plucking some components of <code>Vector3</code> into <code>Vector2</code>;</li>
<li>if you want objects to snap to grid cells: at runtime all you need to do is to <code>Mathf.Round</code> the coordinates, whilst in the editor you can simply drag with Control/Command key pressed;</li>
<li>finally, you may want to actually draw the grid lines on your board/floor — these are usually drawn with either a tileable texture applied on something like a primitive plane, or a shader (or any combination of those).</li></ul>
<p>So there’s little point in actually implementing a “square grid system”, chiefly because you already have <code>Vector2</code> that makes all the above possible.</p>
<p>Why is hex a different story, then?</p>
<figure><svg id="baseGrid"
         class="hexgrid"
         viewBox="-300 -120 600 240">
    </svg>
<p></p></figure>
<p>When presented with a hex grid, we (humans) tend to immediately recognize rows and columns. We’re so used to orthogonal systems in our lives that it’s natural to apply the paradigm we’re so familiar with to all the cases.</p>
<p>Let’s try and put our orthogonal axes onto a hex grid.</p>
<figure><svg id="gridOrthoAxes"
         class="hexgrid"
         viewBox="-300 -120 600 240">
    </svg>
<p></p></figure>
<p>Now you can see two obvious problems with this approach:</p>
<ul><li><p>the width of a regular hexagon doesn’t match its height; depending on which of the two dimensions is chosen as “unit”, the other one will be irrational to this unit;</p></li>
<li><p>the Y axis doesn’t reach the “middle dot” of every other row (one other way to look at this problem is: every other row have horizontal offset)</p></li></ul>
<p>Trying to derive a decent logic to address hex cells with orthogonal coordinates is just plain painful. It’s time to admit that orthogonal system is just not fit for purpose — and to look for some other, more suitable system.</p>
<p>Luckily, there is just one that works perfectly with hexagons. Behold, the <strong>oblique cartesian system</strong> (also known as “axial” or “skewed”):</p>
<figure><svg id="gridObliqueAxes"
         class="hexgrid"
         viewBox="-300 -120 600 240">
    </svg>
<p></p></figure>
<p>Yes, it’s pretty much like the orthogonal one, except that the axes are at 60˚ to each other.</p>
<p class="sidenote">The names of the axes Q and R are chosen to conform to <a href="https://www.redblobgames.com/grids/hexagons/">Amit’s hex guide</a>.</p>
<p>And this makes the whole difference. Notice how both axes go through the middle dots of each “column” and “row”. Essentially, linear combinations of <span style="color: hsl(190, 80%, 50%)">%%\vec q%%</span> and <span style="color: hsl(290, 80%, 60%)">%%\vec r%%</span> unit vectors cover the entire hex space.</p>
<figure><svg id="gridCoordinates"
         class="hexgrid"
         viewBox="-300 -120 600 240">
    </svg>
<p></p></figure>
<p>So implementing a “hex grid system” boils down to creating a <code>Vector2</code> equivalent for oblique coordinates (I’ll refer to them as “hex coordinates”) with conversions to and from our standard orthogonal coordinates.</p>
<p>Everything else would be implemented on top of it. For example, snapping objects to hex grid would be just a matter of getting the rounded hex coordinates and coverting them back to the World coordinates.</p>
<figure><video width="320" height="240" controls autoplay="true" muted="true">
        <source src="/img/posts/hex/hlp-02.mp4"/>
    </video>
<figcaption>Objects snapped to hex grid in Unity Editor.</figcaption></figure>
<h2>Implementation</h2>
<p>Before jumping to the code, we have some choices to make.</p>
<ol><li><p><strong>Orientation</strong>: should each axis go through the vertex of a hexagon or through its side?</p></li>
<li><p><strong>Scale</strong>: how much space should a single cell occupy?</p></li></ol>
<p>So. Hexagons have two radiuses:</p>
<ul><li><a href="https://en.wikipedia.org/wiki/Circumscribed_circle">circumradius</a> %%R%% — the distance from center to vertex, which is also equal to the side of hexagon,</li>
<li><a href="https://en.wikipedia.org/wiki/Incircle_and_excircles_of_a_triangle">inradius</a> %%r%% — the distance from center to side, which is %%{\sqrt 3 \over 2} R%%.</li></ul>
<figure><video width="320" height="240" controls autoplay="true" muted="true">
        <source src="/img/posts/hex/cell-radius.mp4"/>
    </video>
<figcaption>Various choices of hex cell size, compared to a unit sphere.</figcaption></figure>
<p>In the GIF above:</p>
<ul><li><span style="color:hsl(40,75%,50%)">orange hexagon</span> has circumradius %%R = 1%%</li>
<li><span style="color:hsl(200,75%,50%)">blue hexagon</span> has circumradius %%R = 0.5%%</li>
<li><span style="color:hsl(150,60%,45%)">green hexagon</span> has inradius %%r = 0.5%%</li></ul>
<p>I went for the last option (the one with <span style="color:hsl(150,60%,45%)">inradius %%r = 0.5%%</span>), because this way a primitive unit sphere fits perfectly into a single hex grid and nothing overlaps.</p>
<figure><p><img src="/img/posts/hex/capsule-collider.jpg" loading="lazy"/></p>
<figcaption>A capsule collider with radius %%0.5%% around mirror piece.</figcaption></figure>
<p>This also means that both axes go through the side of the hexagons, and not though their vertices.</p>
<p>As for the orientation, I went with aligning Q axis with World X. This one is quite arbitrary, but if it helps: Blender creates cylinders (which you can turn into perfect hexagonal prisms) in this same orientation by default, so you don’t have to rotate anything.</p>
<h2>Put Together</h2>
<p>With all the above in mind let’s create our <code>Hex</code> class stores axial coordinates and converts them into world coordinates.</p>
<pre class="cs"><code>// Hex.cs
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public struct Hex {

    public static float RADIUS = 0.5f;
    public static Vector2 Q_BASIS = new Vector2(2f, 0);
    public static Vector2 R_BASIS = new Vector2(1f, Mathf.Sqrt(3));
    public static Vector2 Q_INV = new Vector2(1f / 2, - Mathf.Sqrt(3) / 6);
    public static Vector2 R_INV = new Vector2(0, Mathf.Sqrt(3) / 3);

    public static Hex FromPlanar(Vector2 planar) {
        float q = Vector2.Dot(planar, Q_INV) / RADIUS;
        float r = Vector2.Dot(planar, R_INV) / RADIUS;
        return new Hex(q, r);
    }

    public static Hex FromWorld(Vector3 world) {
        return FromPlanar(new Vector2(world.x, world.z));
    }

    public int q;
    public int r;

    public Hex(float q, float r) :
        this(Mathf.RoundToInt(q), Mathf.RoundToInt(r)) {}

    public Hex(int q, int r) {
        this.q = q;
        this.r = r;
    }

    public Vector2 ToPlanar() {
        return (Q_BASIS * q + R_BASIS * r) * RADIUS;
    }

    public Vector3 ToWorld(float y = 0f) {
        Vector2 planar = ToPlanar();
        return new Vector3(planar.x, y, planar.y);
    }

    public override bool Equals(System.Object obj) {
        Hex hex = (Hex)obj;
        return (q == hex.q) &amp;&amp; (r == hex.r);
    }

    public override int GetHashCode() {
        return q * 37 + r * 31;
    }

    public override string ToString() {
        return "(" + q + ";" + r + ")";
    }

}
</code></pre>
<p class="sidenote">With <code>Equals</code> and <code>GetHashCode</code> implemented you can use your hexes as <code>Dictionary</code> keys, or put them into <code>HashSet</code>s — very handy for things like breadth-first search. (Also, sorry if it’s obvious)</p>
<p>Here we have static methods <code>Hex.FromPlanar</code> and <code>Hex.FromWorld</code> — these allow obtainining <code>Hex</code> from World coordinates (<code>Vector2</code> and <code>Vector3</code> respectively). Instance methods <code>hex.ToPlanar</code> and <code>hex.ToWorld</code> do the reverse and convert hex coordinates to World coordinates.</p>
<p>I won’t go into any detail with regards to the actual conversion — this stuff is brilliantly explained in the <a href="https://www.redblobgames.com/grids/hexagons/">Amit’s hex guide</a>. Just note how the orientation and scaling decisions are encapsulated in a bunch of static variables at the top (<code>Q_BASIS</code>, <code>R_BASIS</code>, <code>Q_INV</code>, <code>R_INV</code>) — so if you need to change the orientation, these are the things you’d need to tweak.</p>
<h2>Snapping Objects</h2>
<p>With the essentials in place we can now implement a component for snapping objects to hex grid roughly as follows:</p>
<ol><li>convert <code>transform.position</code> to <code>hex</code> using <code>Hex.FromWorld(transform.position)</code>;</li>
<li>convert <code>hex</code> back to <code>Vector3</code> using <code>hex.ToWorld()</code>.</li></ol>
<p>Hex coordinates are integers, so rounding will provide us with that snap we were looking for.</p>
<p>Let’s call our component <code>HexSnap</code>.</p>
<pre class="cs"><code>// HexSnap.cs
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[ExecuteInEditMode]
public class HexSnap : MonoBehaviour {

    public Hex hex {
        get {
            return Hex.FromWorld(transform.position);
        }
    }

    public Hex localHex {
        get {
            return Hex.FromWorld(transform.localPosition);
        }
    }

    public void ApplyTransform() {
        Vector3 newPos = this.localHex.ToWorld(0f);
        transform.localPosition = newPos;
    }

    #if UNITY_EDITOR
    void Update() {
        if (!Application.isPlaying) {
            ApplyTransform();
        }
    }

    void OnDrawGizmosSelected() {
        UnityEditor.Handles.Label(transform.position, hex.ToString());
    }
    #endif

}
</code></pre>
<p>Now attach it to your game object and observe how it snaps onto hex grid floor on XZ plane.</p>
<h2>Neighbours</h2>
<p>Each hex cell has 6 neighbouring cells.</p>
<figure><p><img src="/img/posts/hex/neighbours.jpg" width="240" loading="lazy"/></p></figure>
<p>Let’s list the neighbours of “cell zero” starting with the rightmost one, in counter clockwise direction.</p>
<pre class="cs"><code>// Hex.cs
// ...
    public static Hex[] AXIAL_DIRECTIONS = new Hex[] {
        new Hex(1, 0),
        new Hex(0, 1),
        new Hex(-1, 1),
        new Hex(-1, 0),
        new Hex(0, -1),
        new Hex(1, -1),
    };
</code></pre>
<p>So to find all neighbours of any given <code>hex</code> all we need to do is to loop through these axial directions and add corresponding <code>q</code> and <code>r</code> components.</p>
<p>The only thing missing is component-wise arithmetics of <code>Hex</code> instances, so let’s add them.</p>
<pre class="cs"><code>// Hex.cs
// ...
    public static Hex zero = new Hex(0, 0);

    public static Hex operator +(Hex a, Hex b) {
        return new Hex(a.q + b.q, a.r + b.r);
    }

    public static Hex operator -(Hex a, Hex b) {
        return new Hex(a.q - b.q, a.r - b.r);
    }
</code></pre>
<p>Awesome! Now let’s add few methods to our <code>Hex</code>:</p>
<ul><li><code>Hex GetNeighbour(int dir)</code> to get the neighbouring cell in specified direction,</li>
<li><code>IEnumerable&lt;Hex&gt; Neighbours()</code> to get all cell neighbours.</li></ul>
<pre class="cs"><code>// Hex.cs
// ...
    public Hex GetNeighbour(int dir) {
        Hex incr = AXIAL_DIRECTIONS[dir % AXIAL_DIRECTIONS.Length];
        return this + incr;
    }

    public IEnumerable&lt;Hex&gt; Neighbours() {
        foreach (Hex dir in AXIAL_DIRECTIONS) {
            yield return this + dir;
        }
    }
</code></pre>
<p>Finally, let’s visualize the neighbours. Let’s create a <code>HexNeighbours</code> which would draw gizmos on all neighbouring hex cells:</p>
<pre><code>// HexNeighbours.cs
using UnityEngine;

[ExecuteInEditMode]
public class HexNeighbours : MonoBehaviour {

    public Hex hex {
        get {
            return Hex.FromWorld(transform.position);
        }
    }

    void OnDrawGizmosSelected() {
        Gizmos.color = Color.yellow;
        foreach (Hex neighbour in hex.Neighbours()) {
            Gizmos.DrawSphere(neighbour.ToWorld(), .25f);
        }
    }

}
</code></pre>
<figure><video width="320" height="240" controls autoplay="true" muted="true">
        <source src="/img/posts/hex/neighbours-gizmos.mp4"/>
    </video>
<figcaption>Yellow gizmos showing neighbouring hex cells of currently selected object.</figcaption></figure>
<p class="sidenote">It is very convenient to visualize stuff with gizmos — highly recommended.</p>
<h2>Other Algorithms</h2>
<p>If you’re still with me, then by now you should be getting the feel for it.</p>
<p>Once again I’d like to point you to <a href="https://www.redblobgames.com/grids/hexagons">the most awesome hex grid guides ever created</a> — from here you can choose an algorithm that is relevant to the game you’re making and port it to our hex grid system without much problem.</p>
<p>As an exercise, let’s implement the hex rings traversal.</p>
<pre class="cs"><code>// Hex.cs
// ...

    public static IEnumerable&lt;Hex&gt; Ring(Hex center, int radius) {
        Hex current = center + new Hex(0, -radius);
        foreach (Hex dir in AXIAL_DIRECTIONS) {
            for (int i = 0; i &lt; radius; i++) {
                yield return current;
                current = current + dir;
            }
        }
    }

    public static IEnumerable&lt;Hex&gt; Spiral(Hex center, int minRadius, int maxRadius) {
        if (minRadius == 0) {
            yield return center;
            minRadius += 1;
        }
        for (int r = minRadius; r &lt;= maxRadius; r++) {
            var ring = Ring(center, r);
            foreach (Hex hex in ring) {
                yield return hex;
            }
        }
    }
</code></pre>
<p>As before, let’s visualize it by creating a dummy component and drawing some gizmos.</p>
<pre class="cs"><code>// HexRings.cs
using UnityEngine;

[ExecuteInEditMode]
public class HexRings : MonoBehaviour {

    [Range(1, 10)]
    public int minRadius;
    [Range(1, 10)]
    public int maxRadius;

    public Hex hex {
        get {
            return transform.position.ToHex();
        }
    }

    void OnDrawGizmosSelected() {
        Gizmos.color = Color.magenta;
        foreach (Hex hex in Hex.Spiral(this.hex, minRadius, maxRadius)) {
            Gizmos.DrawSphere(hex.ToWorld(), .25f);
        }
    }

}
</code></pre>
<figure><video width="320" height="240" controls autoplay="true" muted="true">
        <source src="/img/posts/hex/rings.mp4"/>
    </video>
<figcaption>Generated hex rings.</figcaption></figure>
<h2>Conclusion</h2>
<p>Thanks for sticking with me till the end. Time to say goodbye 👋</p>
<p>Hope this was useful, and looking forward to seeing you build something hexy with these ideas.</p>
<p>Also, don’t forget to check out the <a href="https://github.com/inca/UnityHexGrid">demo project on GitHub</a>.</p>
<h2>Addenda</h2>
<p>Here’s how to quickly create a 3D hexagon piece in Blender.</p>
<figure><p><img src="/img/posts/hex/blender-hex.jpg" loading="lazy"/></p>
<figcaption>Blender cylinders use circumradius;<br/>
        type <code>sqrt(3) / 3</code> to get the cylinder with inradius %%0.5%%</figcaption></figure>
</div></article></div></div><div class="footer"><div class="footer__container container"></div></div><script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer src="/lib/highlight.pack.js"></script><script defer src="/build/main.js"></script><script defer src="/build/dev.js"></script></body></html>